import do_mpc
import numpy as np
import casadi as csd

class MPCController:
    def __init__(self, Te=0.1, horizon=20):
        self.horizon = horizon

        # Model and MPC setup
        self.model = do_mpc.model.Model('continuous')
        self.setup_model()
        self.mpc = do_mpc.controller.MPC(self.model)
        self.setup_mpc(Te, horizon)

    def setup_model(self):
        # Define model variables
        x   = self.model.set_variable(var_type='_x', var_name='x')   # Position in x-direction
        y   = self.model.set_variable(var_type='_x', var_name='y')   # Position in y-direction
        phi = self.model.set_variable(var_type='_x', var_name='phi') # Yaw angle
        u   = self.model.set_variable(var_type='_x', var_name='u')   # Surge velocity
        v   = self.model.set_variable(var_type='_x', var_name='v')   # Sway velocity
        r   = self.model.set_variable(var_type='_x', var_name='r')   # Yaw rate

        omega_1 = self.model.set_variable(var_type='_u', var_name='omega_1')  # Left thruster rotation speed
        theta_1 = self.model.set_variable(var_type='_u', var_name='theta_1')  # Left thruster angle
        omega_2 = self.model.set_variable(var_type='_u', var_name='omega_2')  # Right thruster rotation speed
        theta_2 = self.model.set_variable(var_type='_u', var_name='theta_2')  # Right thruster angle

        ###################################################### MODEL 1 ###################################################
        m = 1000.0       # Mass of the USV [kg]
        I_z = 446.0      # Yaw moment of inertia [kg*m^2]

        # Hydrodynamic damping coefficients
        xU = 200.0
        xUU = 300.0
        yV = 200.0
        yVV = 200.0
        nR = 1600.0
        nRR = 1600.0

        # Positions of thrusters relative to the center of mass [m]
        x_L = -3.0     # Left thruster x-position
        y_L = 0.6      # Left thruster y-position
        x_R = -3.0     # Right thruster x-position
        y_R = -0.6     # Right thruster y-position

        # Dynamic model equations

        # Compute thrust forces
        T1 = omega_1  # Assuming direct proportionality between omega and thrust
        T2 = omega_2

        # Force components in the body-fixed frame
        F1_x = T1 * csd.cos(theta_1)
        F1_y = T1 * csd.sin(theta_1)
        F2_x = T2 * csd.cos(theta_2)
        F2_y = T2 * csd.sin(theta_2)

        # Moments generated by each thruster about the center of mass
        N1 = x_L * F1_y - y_L * F1_x
        N2 = x_R * F2_y - y_R * F2_x

        # Total forces and moments from thrusters
        X_T = F1_x + F2_x
        Y_T = F1_y + F2_y
        N_T = N1 + N2

        # Hydrodynamic damping forces and moments
        X_D = - xU * u - xUU * u * csd.fabs(u)
        Y_D = - yV * v - yVV * v * csd.fabs(v)
        N_D = - nR * r - nRR * r * csd.fabs(r)

        # Total forces and moments acting on the USV
        X = X_T + X_D
        Y = Y_T + Y_D
        N = N_T + N_D

        # Equations of motion (body-fixed frame)
        u_dot = (X + m * v * r) / m
        v_dot = (Y - m * u * r) / m
        r_dot = N / I_z

        # Kinematic equations (transforming body-fixed velocities to inertial frame)
        x_dot = u * csd.cos(phi) - v * csd.sin(phi)
        y_dot = u * csd.sin(phi) + v * csd.cos(phi)
        phi_dot = r

        ##########################################################################################################################################
        self.model.set_rhs('x', x_dot)
        self.model.set_rhs('y', y_dot)
        self.model.set_rhs('phi', phi_dot)
        self.model.set_rhs('u', u_dot)
        self.model.set_rhs('v', v_dot)
        self.model.set_rhs('r', r_dot)

        # Define references for cost calculation
        self.model.set_variable('_tvp', 'x_ref')
        self.model.set_variable('_tvp', 'y_ref')
        self.model.set_variable('_tvp', 'phi_ref')

        self.model.setup()


    def setup_mpc(self, Te, horizon):
        # MPC Parameters
        setup_mpc = {
            'n_horizon': horizon,
            't_step': Te,
            'state_discretization': 'collocation',
            'store_full_solution': True,
        }
        self.mpc.set_param(**setup_mpc)

        # Define weighting matrices
        Q = np.diag([10.0, 10.0, 20.0])   # Weights for state error 
        R = np.diag([0.01, 0.01, 0.005, 0.005])  # Weights for input smoothnes error

        # Define state error
        x_error = self.model.x['x'] - self.model.tvp['x_ref']
        y_error = self.model.x['y'] - self.model.tvp['y_ref']
        phi_error = self.model.x['phi'] - self.model.tvp['phi_ref']

        # State error vector
        state_error = csd.vertcat(x_error, y_error, phi_error)
        # Control vector
        control_input = csd.vertcat(self.model.u['omega_1'], self.model.u['omega_2'], self.model.u['theta_1'], self.model.u['theta_2'])

        # Stage cost
        lterm = state_error.T @ Q @ state_error + control_input.T @ R @ control_input
        # Terminal cost
        mterm = state_error.T @ Q @ state_error

        self.mpc.set_objective(mterm=mterm, lterm=lterm)

        # Set control weightings for rate of change (optional)
        self.mpc.set_rterm(
            omega_1=R[0, 0],
            omega_2=R[1, 1],
            theta_1=R[2, 2],
            theta_2=R[3, 3]
        )

        # Set bounds for control inputs
        self.mpc.bounds['lower', '_u', 'omega_1'] = -5000.0
        self.mpc.bounds['upper', '_u', 'omega_1'] =  5000.0
        self.mpc.bounds['lower', '_u', 'omega_2'] = -5000.0
        self.mpc.bounds['upper', '_u', 'omega_2'] =  5000.0
        self.mpc.bounds['lower', '_u', 'theta_1'] = -np.pi / 4
        self.mpc.bounds['upper', '_u', 'theta_1'] =  np.pi / 4
        self.mpc.bounds['lower', '_u', 'theta_2'] = -np.pi / 4
        self.mpc.bounds['upper', '_u', 'theta_2'] =  np.pi / 4

        # Time-varying parameters (reference path)
        tvp_template = self.mpc.get_tvp_template()

        def tvp_fun(t_now):
            for i in range(horizon + 1):
                tvp_template['_tvp', i, 'x_ref'] = 0  # Placeholder for x_ref values
                tvp_template['_tvp', i, 'y_ref'] = 0  # Placeholder for y_ref values
                tvp_template['_tvp', i, 'phi_ref'] = 0  # Placeholder for phi_ref values
            return tvp_template

        self.mpc.set_tvp_fun(tvp_fun)
        self.mpc.setup()

    def compute_control(self, current_state, reference_path):
        # Set current state
        x, y, phi, u, v, r = current_state
        self.mpc.x0 = np.array([x, y, phi, u, v, r])

        # Update MPC with reference path
        def tvp_fun_update(t_now):
            tvp_template = self.mpc.get_tvp_template()
            for i in range(self.horizon + 1):
                if i < len(reference_path):
                    tvp_template['_tvp', i, 'x_ref'] = reference_path[i][0]
                    tvp_template['_tvp', i, 'y_ref'] = reference_path[i][1]
                    tvp_template['_tvp', i, 'phi_ref'] = reference_path[i][2]
                else:
                    # Repeat the last reference point if the path is shorter
                    tvp_template['_tvp', i, 'x_ref'] = reference_path[-1][0]
                    tvp_template['_tvp', i, 'y_ref'] = reference_path[-1][1]
                    tvp_template['_tvp', i, 'phi_ref'] = reference_path[-1][2]
            return tvp_template

        self.mpc.set_tvp_fun(tvp_fun_update)

        # Make prediction and compute next control input
        u0 = self.mpc.make_step(self.mpc.x0)

        # Extract predicted states for 'x', 'y', and 'phi'
        predicted_states = {}
        for var_name in ['x', 'y', 'phi']:
            predicted_state = self.mpc.data.prediction(('_x', var_name))
            # Convert predicted_state to a 1D list of floats
            predicted_states[var_name] = np.array(predicted_state).squeeze().tolist()

        # Extract predicted control inputs over the horizon
        predicted_controls = {}
        for var_name in ['omega_1', 'theta_1', 'omega_2', 'theta_2']:
            predicted_control = self.mpc.data.prediction(('_u', var_name))
            # Convert predicted_control to a 1D list of floats
            predicted_controls[var_name] = np.array(predicted_control).squeeze().tolist()

        return u0, predicted_states, predicted_controls
